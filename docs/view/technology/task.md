# 事件循环

javascript是一门单线程的非阻塞的脚本语言，这意味着javascript程序在执行时，只有一个主线程来处理所有任务。  

如果同步处理一些需要较长时间才有结果的任务容易造成阻塞，所以javascript中有同步任务、异步任务，其中异步任务就是用来处理这种情况。  

事件循环则机制决定了javascript中任务的运行顺序，从而使得javascript在运行时能够有 `非阻塞` 的特点。  


__执行栈__  

函数被执行时会往执行栈中压入其执行环境，当函数执行完毕时其对应的执行环境会被弹出执行栈，出入栈遵循着后入先出的规则。当栈被清空时也就意味着函数执行完毕。

```js
    function inFn(){

    }

    function outFn(){
        inFn()
    }

    outFn()
```

当调用 `outfn` 时， `outfn` 对应的执行环境先被压入执行栈，然后调用 `inFn` 其对应的执行环境被压入执行栈， `inFn` 执行完毕，对应的执行环境被弹出执行栈，最后 `outFn` 也执行完毕，对应的执行环境也被弹出执行栈，此时函数执行完毕，栈中也被清空。

__队列__  

一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。
当函数运行时碰到非微任务的异步事件时，不会立刻执行该函数，而是将其加入消息队列中等待执行栈为空后再依次执行。  

__事件循环__  

js引擎在执行一个函数时，会向执行栈中压入其执行环境，在执行这个函数时可能也会调用到其他函数，其结果也不过是往执行栈中加入对应函数的执行环境。当碰到异步事件时，js会根据该异步事件的类型，将其加入微任务队列（微任务）或消息队列（宏任务），然后继续执行其他同步代码。当执行栈为空时，js会先查看微任务队列中是否有任务，如果有就会将微任务队列中的任务加入执行栈中执行，直到微任务队列为空后，js会将消息队列中的一个任务加入执行栈中，然后执行其中的同步代码，如此反复，就形成了一个循环，这个过程就被成为事件循环。  

```js
    console.log(1);

    setTimeout(()=>{
       console.log(2)
       Promise.resolve().then(()=>{console.log(3)})
    })

    Promise.resolve().then(()=>{
       console.log(4)
       setTimeout(()=>{console.log(5)})
    }) 

    console.log(6)
    // 1 6 4 2 3 5
```


