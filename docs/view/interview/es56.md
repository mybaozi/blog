# es5、6

### ES5

__call、apply__

```js
    let obj = { a: 1 }
    function fn(){
        console.log(this.a)
    }
    fn()           // undefined
    fn.call(obj)   // 1
    fn.apply(obj)  // 1
```

__新增数组方法__

every、some、forEach、map、filter、reduce


### ES6

__let/const__

1、不存在变量提升  
2、存在暂时性死区  
3、同一作用域中不允许重复声明  
4、存在块级作用域，作用域之外不能访问  

__字符串方法__

1、includes  
2、startsWith  
3、endsWith  

__for of遍历__
```js
let arr = ['a','b','c']
for(let item of arr){
    console.log(item) // a b c
}
```

__模板字符串__

```js
let word = "world"
let str = `hellow,${word}`
```

__箭头函数__

不需要 `function` 关键字来创建函数  
可以省略 `return` 关键字  
this指向上一级
```js
let fn = (x) => {
  console.log(x)
}
```

__结构赋值__

```js
let arr = [1,2,3,,undefined,null];
let [a,b,c,d = 1,e = 1 ,f = 1] = arr;
console.log(a,b,c,d,e,f) // 1 2 3 1 1 null

let obj = {
    a:1,
    b:2,
    c:3,
    d:undefined,
    f:null
}
let {a,b,c,d = 1,f = 1} = obj;
console.log(a,b,c,d,f) // 1 2 3 1 null
```

__Symbol类型__

```js
let a = Symbol('a'); //Symbol(a)
```

__Set 函数__

可用在数组去重
```js
let arr = [...new Set([1,1,2,2,3,4,5])] // arr: [1,2,3,4,5]
```

__Map集合__

```js
let map = new Map()
map.set(1,1)
map.set('a','a')
map.get(1) // 1
map.get('a') // 'a'
for(let i of map){
    console.log(i) // [1,1] ['a','a']
}
```

__bind__

改变一个函数中this的指向，且返回一个新函数
```js
let obj = {
    id: 1
}
function fn(){
    console.log(this.id)
}
let newFn = fn.bind(obj)
newFn() // 1
```

__class 类__

两种创建类的方式

```js
  // 类表达式
  let Fn = class{}
  // 类声明
  class Fn{}
```

es6中的类(class)是构造函数的语法糖
与构造函数相同，可以通过new关键字生成一个新的对象。

```js
  //声明一个类 类名为Person 
  class Person{
    constructor(name,age){
      this.name = name;
      this.age = age;
    }
    info(){
      console.log(`姓名：${this.name},年龄：${this.age}`)
    }
  }

  // 以上通过class声明的类中的constructor方法等同以下构造函数
  function Person(name,age){
    this.name = name;
    this.age = age;
  }
  // class中除constructor这个方法，其他声明的方法等同于以下给构造函数原型赋值方法
  Person.prototype.info = function(){
    console.log(`姓名：${this.name},年龄：${this.age}`)
  }

```

__Promise__

通过 `Promise` 创建一个 `promise` 对象时并不是异步操作，所以一般要封装在一个函数中，待使用时通过该函数返回创建并返回一个 `promise` 对象。

promise的优势：  
可以通过链式操作执行返回结果，避免出现回调地狱，提高代码可读性。

三种状态：  
Pending resolved（fulfilled） rejected
```js
  let promise = function (){
    return new Promise((resolve,reject)=>{
      setTimeout(()=>{
        let result = { status: Math.random() > 0.5 ? true : false , data: '数据'}
        console.log(result)
        if(result.status){
          resolve(result.data)
        }else{
          reject(result.data)
        }
      },2000)

    })
  }
  promise().then(
    (res)=>{
      //成功回调
      console.log('成功',res)
    },
    (error)=>{
      //失败回调
      throw Error('失败',error)
    }
  )
```